---
title: React 效能優化工具與套件指南
description: 針對 MAYO-PT-Web 專案的 React 效能優化工具、套件選擇與實作建議
tags: [React, 效能優化, 開發工具, 監控, 測試]
published: 2025-10-14
draft: false
---

# React 效能優化工具與套件指南

> **文件版本：** v1.0
> **建立日期：** 2025-10-14
> **適用專案：** MAYO-PT-Web

---

## 📋 目錄

1. [效能分析工具](#1-效能分析工具)
2. [開發工具](#2-開發工具)
3. [優化套件](#3-優化套件)
4. [測試工具](#4-測試工具)
5. [監控工具](#5-監控工具)
6. [實作建議](#6-實作建議)

---

## 1. 效能分析工具

### 1.1 React DevTools Profiler

**用途：** 分析 React 組件渲染效能

**安裝：**
```bash
# Chrome/Firefox 擴充套件
# 直接從瀏覽器商店安裝 React Developer Tools
```

**使用方式：**
1. 開啟 React DevTools
2. 切換到 "Profiler" 標籤
3. 點擊錄製按鈕
4. 執行要分析的操作
5. 停止錄製並查看結果

**關鍵指標：**
- **Render duration** - 組件渲染時間
- **Commit duration** - 提交到 DOM 的時間
- **Why did this render?** - 渲染原因分析

**範例：分析 ShiftScheduleApproval**
```tsx
// 在開發環境中使用 Profiler API
import { Profiler } from 'react';

const ShiftScheduleApprovalPage = () => {
  const onRenderCallback = (
    id: string,
    phase: "mount" | "update",
    actualDuration: number,
    baseDuration: number,
    startTime: number,
    commitTime: number,
  ) => {
    console.log(`${id} (${phase}) took ${actualDuration}ms`);
  };

  return (
    <Profiler id="ShiftScheduleApproval" onRender={onRenderCallback}>
      {/* 組件內容 */}
    </Profiler>
  );
};
```

---

### 1.2 Why Did You Render

**用途：** 檢測不必要的組件重新渲染

**安裝：**
```bash
npm install --save-dev @welldone-software/why-did-you-render
# or
yarn add -D @welldone-software/why-did-you-render
```

**設定：**
```tsx
// src/wdyr.ts (僅在開發環境使用)
import React from 'react';

if (process.env.NODE_ENV === 'development') {
  const whyDidYouRender = require('@welldone-software/why-did-you-render');
  whyDidYouRender(React, {
    trackAllPureComponents: true,
    trackHooks: true,
    logOnDifferentValues: true,
  });
}
```

**使用方式：**
```tsx
// 在要追蹤的組件上添加標記
const SearchBarFields: React.FC<SearchBarFieldsProps> = (props) => {
  // ... 組件邏輯
};

// 開發環境下啟用追蹤
SearchBarFields.whyDidYouRender = true;

export default SearchBarFields;
```

**輸出範例：**
```
SearchBarFields re-rendered because:
  - props.departmentOptions changed
  - props.workHoursTypeOptions changed (but values are equal)
```

---

### 1.3 Chrome DevTools Performance

**用途：** 深入分析瀏覽器效能

**使用方式：**
1. 開啟 Chrome DevTools (F12)
2. 切換到 "Performance" 標籤
3. 點擊錄製按鈕
4. 執行要分析的操作
5. 停止錄製並查看火焰圖

**關鍵指標：**
- **FPS** - 每秒幀數（目標 60fps）
- **CPU** - CPU 使用率
- **Main Thread** - 主線程活動
- **Memory** - 記憶體使用

---

## 2. 開發工具

### 2.1 ESLint Plugin React

**用途：** 靜態代碼分析，檢測效能問題

**安裝：**
```bash
npm install --save-dev eslint-plugin-react eslint-plugin-react-hooks
```

**設定：**
```json
// .eslintrc.json
{
  "extends": [
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "react/jsx-no-bind": "warn",
    "react/no-array-index-key": "warn",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

**檢測項目：**
- ✅ Hooks 依賴項檢查
- ✅ 不必要的 re-render
- ✅ 內聯函數警告
- ✅ Key prop 使用

---

### 2.2 TypeScript Strict Mode

**用途：** 型別安全，減少執行時錯誤

**設定：**
```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

---

## 3. 優化套件

### 3.1 React.memo / useMemo / useCallback

**內建 React API，無需安裝**

**使用範例：**

```tsx
// React.memo - 組件記憶化
import { memo } from 'react';

const SearchBarFields = memo<SearchBarFieldsProps>(({ 
  departmentOptions,
  workHoursTypeOptions,
  isDepartmentsLoading,
}) => {
  // ... 組件邏輯
});

// useMemo - 值記憶化
const viewModeOptions = useMemo(() => 
  VIEW_MODE_OPTIONS.map(opt => ({ ...opt, label: t(opt.label) })),
  [t]
);

// useCallback - 函數記憶化
const renderCalendar = useCallback(() => {
  if (isLoading) return <LoadingState />;
  if (hasScheduleData) return <ScheduleCalendar days={scheduleDays} />;
  return <EmptyState />;
}, [isLoading, hasScheduleData, scheduleDays]);
```

---

### 3.2 React Window / React Virtualized

**用途：** 虛擬化長列表，只渲染可見項目

**安裝：**
```bash
npm install react-window
# or
npm install react-virtualized
```

**使用範例（適用於大量員工列表）：**
```tsx
import { FixedSizeList } from 'react-window';

const EmployeeList: React.FC<{ employees: Employee[] }> = ({ employees }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <EmployeeRow employee={employees[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={employees.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
};
```

**效能提升：**
- 1000+ 項目列表：提升 80-90% 渲染速度
- 記憶體使用：減少 70-80%

---

### 3.3 Immer

**用途：** 不可變數據更新，簡化狀態管理

**安裝：**
```bash
npm install immer
```

**使用範例：**
```tsx
import { produce } from 'immer';

// 傳統方式（容易出錯）
const updateSchedule = (schedule: Schedule, updates: Partial<Schedule>) => {
  return {
    ...schedule,
    shifts: schedule.shifts.map(shift => 
      shift.id === updates.id ? { ...shift, ...updates } : shift
    ),
  };
};

// 使用 Immer（更簡潔、更安全）
const updateSchedule = (schedule: Schedule, updates: Partial<Schedule>) => {
  return produce(schedule, draft => {
    const shift = draft.shifts.find(s => s.id === updates.id);
    if (shift) {
      Object.assign(shift, updates);
    }
  });
};
```

---

### 3.4 React Query / SWR

**用途：** 數據獲取和快取優化

**專案已使用 React Query (@tanstack/react-query)**

**優化建議：**
```tsx
// 使用 staleTime 和 cacheTime 優化
const { data: scheduleData } = useQuery({
  queryKey: ['shiftSchedule', params],
  queryFn: () => fetchShiftSchedule(params),
  staleTime: 5 * 60 * 1000, // 5 分鐘內不重新獲取
  cacheTime: 10 * 60 * 1000, // 快取保留 10 分鐘
  refetchOnWindowFocus: false, // 視窗聚焦時不重新獲取
});

// 使用 prefetch 預先載入數據
const queryClient = useQueryClient();
queryClient.prefetchQuery({
  queryKey: ['shiftSchedule', nextParams],
  queryFn: () => fetchShiftSchedule(nextParams),
});
```

---

## 4. 測試工具

### 4.1 React Testing Library

**用途：** 組件測試，確保優化不影響功能

**安裝：**
```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom
```

**效能測試範例：**
```tsx
import { render, screen } from '@testing-library/react';
import { ShiftScheduleApprovalView } from './ShiftScheduleApprovalView';

describe('ShiftScheduleApprovalView Performance', () => {
  it('should not re-render when props do not change', () => {
    const props = {
      isPageLoading: false,
      hasNoData: false,
      // ... 其他 props
    };

    const { rerender } = render(<ShiftScheduleApprovalView {...props} />);
    
    // 使用相同 props 重新渲染
    const renderCount = jest.fn();
    rerender(<ShiftScheduleApprovalView {...props} />);
    
    // 驗證組件沒有不必要的重新渲染
    expect(renderCount).not.toHaveBeenCalled();
  });
});
```

---

### 4.2 Lighthouse

**用途：** 網頁效能評分

**使用方式：**
1. 開啟 Chrome DevTools
2. 切換到 "Lighthouse" 標籤
3. 選擇 "Performance" 類別
4. 點擊 "Generate report"

**關鍵指標：**
- **FCP** (First Contentful Paint) - 首次內容繪製
- **LCP** (Largest Contentful Paint) - 最大內容繪製
- **TBT** (Total Blocking Time) - 總阻塞時間
- **CLS** (Cumulative Layout Shift) - 累積佈局偏移

**目標分數：**
- Performance: 90+
- Accessibility: 90+
- Best Practices: 90+

---

## 5. 監控工具

### 5.1 Sentry Performance Monitoring

**用途：** 生產環境效能監控

**安裝：**
```bash
npm install @sentry/react
```

**設定：**
```tsx
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: "YOUR_SENTRY_DSN",
  integrations: [
    new Sentry.BrowserTracing(),
  ],
  tracesSampleRate: 0.1, // 10% 的交易進行追蹤
});

// 追蹤特定操作
const transaction = Sentry.startTransaction({
  name: "Load Shift Schedule",
});

// ... 執行操作

transaction.finish();
```

---

### 5.2 Web Vitals

**用途：** 追蹤核心網頁指標

**安裝：**
```bash
npm install web-vitals
```

**使用：**
```tsx
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

const reportWebVitals = (metric: any) => {
  console.log(metric);
  // 發送到分析服務
};

getCLS(reportWebVitals);
getFID(reportWebVitals);
getFCP(reportWebVitals);
getLCP(reportWebVitals);
getTTFB(reportWebVitals);
```

---

## 6. 實作建議

### 6.1 ShiftScheduleApproval 優化工具組合

**階段一：分析階段**
```bash
# 1. 安裝分析工具
npm install --save-dev @welldone-software/why-did-you-render

# 2. 設定 wdyr.ts
# 3. 使用 React DevTools Profiler 錄製
# 4. 使用 Chrome Performance 分析
```

**階段二：優化階段**
```bash
# 1. 應用 React.memo / useMemo / useCallback
# 2. 提取常量和組件
# 3. 使用 ESLint 檢查
```

**階段三：驗證階段**
```bash
# 1. 再次使用 Profiler 比較
# 2. 執行 Lighthouse 測試
# 3. 編寫效能測試
```

---

### 6.2 效能優化檢查清單

#### 組件層級
- [ ] 使用 `React.memo` 包裹純展示組件
- [ ] 使用 `useCallback` 包裹事件處理函數
- [ ] 使用 `useMemo` 快取計算結果
- [ ] 避免內聯對象和陣列創建
- [ ] 提取常量到組件外部

#### 數據層級
- [ ] 配置 React Query 快取策略
- [ ] 使用 `staleTime` 減少重複請求
- [ ] 實作樂觀更新 (Optimistic Updates)
- [ ] 使用 `prefetch` 預載數據

#### 渲染層級
- [ ] 條件渲染改為控制 props
- [ ] 大列表使用虛擬化
- [ ] 圖片使用懶加載
- [ ] 代碼分割 (Code Splitting)

#### 監控層級
- [ ] 設定 Sentry 效能監控
- [ ] 追蹤 Web Vitals
- [ ] 定期執行 Lighthouse 測試
- [ ] 建立效能基準線

---

### 6.3 效能預算

**為 ShiftScheduleApproval 設定效能預算：**

| 指標 | 目標 | 警告 | 錯誤 |
|------|------|------|------|
| 首次渲染時間 | < 1s | 1-2s | > 2s |
| 組件更新時間 | < 100ms | 100-200ms | > 200ms |
| 記憶體使用 | < 50MB | 50-100MB | > 100MB |
| Bundle 大小 | < 500KB | 500KB-1MB | > 1MB |
| Lighthouse 分數 | > 90 | 80-90 | < 80 |

---

## 📚 參考資源

### 官方文檔
- [React DevTools](https://react.dev/learn/react-developer-tools)
- [React Profiler API](https://react.dev/reference/react/Profiler)
- [Web Vitals](https://web.dev/vitals/)

### 工具文檔
- [Why Did You Render](https://github.com/welldone-software/why-did-you-render)
- [React Window](https://react-window.vercel.app/)
- [Sentry Performance](https://docs.sentry.io/product/performance/)

### 最佳實踐
- [React Performance Optimization](https://react.dev/learn/render-and-commit)
- [Optimizing Performance](https://legacy.reactjs.org/docs/optimizing-performance.html)

---

**文件維護者：** AI Assistant  
**最後更新：** 2025-10-14  
**版本：** v1.0

